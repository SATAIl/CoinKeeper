# CoinKeeper – Backend Template (Labs 1–2)

## Overview

CoinKeeper is a small backend service used as a template for the **“Server-Side Software Technologies”** labs.

It is implemented with **Node.js + TypeScript + Express** and exposes a simple REST API for:

- Lab 1 – basic backend setup with a `/healthcheck` endpoint and deployment.
- Lab 2 – in‑memory REST API for users, categories and expense records.

The application is containerized with Docker and can be run locally or deployed to platforms such as Render.com.

---

## Tech Stack

- **Language:** TypeScript
- **Runtime:** Node.js 18 (LTS)
- **Framework:** Express
- **Build:** TypeScript compiler (`tsc`)
- **Containerization:** Docker, Docker Compose

---

## Project Structure

```text
.
├── src
│   ├── app.ts              # Express app, route registration
│   ├── server.ts           # Entry point – starts HTTP server
│   ├── models
│   │   ├── user.ts         # User interface
│   │   ├── category.ts     # Category interface
│   │   └── record.ts       # Record interface
│   ├── storage
│   │   └── db.ts           # In‑memory data storage and ID generators
│   └── routes
│       ├── healthcheck.ts  # /healthcheck endpoint (Lab 1)
│       ├── users.ts        # /users, /user/:id
│       ├── categories.ts   # /category, /category/:id
│       └── records.ts      # /record, /record/:id
├── dist/                   # Compiled JavaScript (generated)
├── package.json
├── tsconfig.json
├── Dockerfile
└── docker-compose.yml
```

---

## Getting Started

### Prerequisites

To run the project locally you will need:

- **Node.js** v18.x (or compatible)
- **npm**
- Optionally **Docker** and **Docker Compose**
- Any HTTP client for testing (Insomnia, Postman, curl, etc.)

### Installation

```bash
npm install
```

### Development run (TypeScript directly)

```bash
npm run dev
```

This command starts the server using `ts-node-dev` and automatically reloads on file changes.

### Production build and run

```bash
npm run build   # compile TypeScript to dist/
npm start       # run compiled JavaScript from dist/server.js
```

By default the application listens on:

- `PORT` environment variable if it is set;
- otherwise port `3000`.

So locally the base URL is usually:

- `http://localhost:3000`

---

## Running with Docker

You can run the service inside a Docker container.

### Build and run with Docker directly

```bash
docker build -t coinkeeper .
docker run -p 8080:3000 -e PORT=3000 coinkeeper
```

The service will be available at:

- `http://localhost:8080/`
- `http://localhost:8080/healthcheck`

### Run with Docker Compose

The repository contains a `docker-compose.yml` file.

```bash
docker-compose up --build
```

After the containers start, the backend will be available at:

- `http://localhost:8080/`
- `http://localhost:8080/healthcheck`

---

## API Reference

All endpoints are prefixed only by their path (no versioning). Examples below assume `http://localhost:3000` as base URL.

### Common

#### `GET /`

Simple welcome endpoint to verify that the service is reachable.

- **Status:** `200 OK`
- **Response body (text):**

  ```text
  Welcome to CoinKeeper!
  ```

#### `GET /healthcheck`

Healthcheck endpoint used for Render and local monitoring.

- **Status:** `200 OK`
- **Response (JSON):**

  ```json
  {
    "date": "2025-01-01T00:00:00.000Z",
    "status": "OK",
    "message": "Healthcheck passed"
  }
  ```

The `date` field is generated on each request with the current server time in ISO 8601 format.

---

### Data Model (Lab 2)

All data in Lab 2 is stored **in memory only** – there is no database yet.

- **User**
  - `id` – number
  - `name` – string

- **Category**
  - `id` – number
  - `name` – string

- **Record**
  - `id` – number
  - `userId` – number (existing user)
  - `categoryId` – number (existing category)
  - `createdAt` – ISO datetime string (generated by the server)
  - `amount` – number

IDs are generated by simple in‑memory counters.

---

### Users

#### `GET /users`

Returns all users.

- **Status:** `200 OK`
- **Response:** array of `User`

#### `GET /user/:userId`

Returns a single user by id.

- **Status 200:** user found, JSON body with `User`
- **Status 404:** `{ "error": "User not found" }`

#### `POST /user`

Creates a new user.

- **Body (JSON):**

  ```json
  {
    "name": "Andrii"
  }
  ```

- **Status 201:** created user with generated `id`
- **Status 400:** if `name` is missing

#### `DELETE /user/:userId`

Deletes a user and all of their records.

- **Status 204:** user was deleted
- **Status 404:** if user does not exist

---

### Categories

#### `GET /category`

Returns all categories.

- **Status:** `200 OK`
- **Response:** array of `Category`

#### `POST /category`

Creates a new category.

- **Body (JSON):**

  ```json
  {
    "name": "Food"
  }
  ```

- **Status 201:** created category
- **Status 400:** if `name` is missing

#### `DELETE /category/:categoryId`

Deletes a category and all records that reference it.

- **Status 204:** category deleted
- **Status 404:** if category does not exist

---

### Records

#### `GET /record/:recordId`

Returns one expense record by id.

- **Status 200:** record found
- **Status 404:** `{ "error": "Record not found" }`

#### `POST /record`

Creates a new expense record.

- **Body (JSON):**

  ```json
  {
    "userId": 1,
    "categoryId": 2,
    "amount": 123.45
  }
  ```

- Server automatically sets:
  - `id` – generated number
  - `createdAt` – current time in ISO 8601 format

- **Status 201:** created record
- **Status 400:** if fields are missing, not numbers, or if the referenced user/category does not exist

#### `GET /record`

Returns records filtered by query parameters.

- **Query parameters:**
  - `user_id` – optional user id
  - `category_id` – optional category id

Rules:

- If **neither** `user_id` nor `category_id` is provided →  
  **Status 400** with error message:
  - `"At least one of 'user_id' or 'category_id' must be provided"`
- If only `user_id` is provided → return all records of this user.
- If only `category_id` is provided → return all records in this category.
- If both are provided → return records that match **both** filters.

#### `DELETE /record/:recordId`

Deletes a record.

- **Status 204:** record deleted
- **Status 404:** if record does not exist

---

## Deployment to Render.com (example)

This project is prepared to be deployed as a **Docker web service** on Render.

Typical steps:

1. Push the project to a Git repository (e.g. GitHub).
2. In Render, create **New → Web Service**.
3. Choose:
   - **Environment / Language:** `Docker`
   - **Branch:** `main`
4. Leave the root directory empty (or set it to the folder name if the project is inside a subdirectory).
5. Keep default Docker build settings – Render will build the image using the `Dockerfile` in the repository.
6. After deployment, Render will expose a public URL such as:

   - `https://coinkeeper-m784.onrender.com`

7. Verify the service:

   - `https://coinkeeper-m784.onrender.com/healthcheck`
   - `https://coinkeeper-m784.onrender.com/users` (after you create some users)
   - `https://coinkeeper-m784.onrender.com/record` (with query parameters)

---

## Postman Flow

The following flow was created in Postman to demonstrate how the API can be used end-to-end:

![CoinKeeper Postman Flow](lab2-flow.jpg)

## Labs Mapping

### Lab 1 – Backend preparation

This project satisfies the Lab 1 requirements:

- ✅ Backend environment configured (Node.js + TypeScript + Express).
- ✅ Healthcheck endpoint implemented (`GET /healthcheck`).
- ✅ Service can be run locally and in Docker.
- ✅ Project prepared for deployment on Render.com (uses `PORT` env variable).
- ✅ README with clear instructions for setup and manual testing.

### Lab 2 – In‑memory REST API

This project also covers Lab 2:

- ✅ In‑memory data model for **users**, **categories** and **records**.
- ✅ Full CRUD endpoints for all entities (except updates, which are not required).
- ✅ Special behaviour for `GET /record`:
  - returns **400 Bad Request** when called without `user_id` or `category_id`.
- ✅ All endpoints can be tested via Postman / Insomnia and used in Postman Collections & Flows required by the lab.

The same codebase can be extended in later labs with validation, database support and authentication without changing the public API.
