# CoinKeeper – Backend Template (Labs 1–3)

## Overview

CoinKeeper is a small backend service used as a template for the **“Server-Side Software Technologies”** labs.

It is implemented with **Node.js + TypeScript + Express** and exposes a simple REST API for:

- Lab 1 – basic backend setup with a `/healthcheck` endpoint and deployment.
- Lab 2 – in‑memory REST API for users, categories and expense records.
- Lab 3 – request validation, centralized error handling and PostgreSQL database integration via Prisma ORM.

The application is containerized with Docker and can be run locally or deployed to platforms such as Render.com.

---

## Tech Stack

- **Language:** TypeScript
- **Runtime:** Node.js 18 (LTS)
- **Framework:** Express
- **Build:** TypeScript compiler (`tsc`)
- **Containerization:** Docker, Docker Compose

---

## Project Structure

```text
.
├── src
│   ├── app.ts              # Express app, route registration
│   ├── server.ts           # Entry point – starts HTTP server
│   ├── models
│   │   ├── user.ts         # User interface
│   │   ├── category.ts     # Category interface
│   │   └── record.ts       # Record interface
│   ├── storage
│   │   └── db.ts           # In‑memory data storage and ID generators
│   └── routes
│       ├── healthcheck.ts  # /healthcheck endpoint (Lab 1)
│       ├── users.ts        # /users, /user/:id
│       ├── categories.ts   # /category, /category/:id
│       └── records.ts      # /record, /record/:id
├── dist/                   # Compiled JavaScript (generated)
├── package.json
├── tsconfig.json
├── Dockerfile
└── docker-compose.yml
```

---

## Getting Started

### Prerequisites

To run the project locally you will need:

- **Node.js** v18.x (or compatible)
- **npm**
- Optionally **Docker** and **Docker Compose**
- Any HTTP client for testing (Insomnia, Postman, curl, etc.)

### Installation

```bash
npm install
```

### Development run (TypeScript directly)

```bash
npm run dev
```

This command starts the server using `ts-node-dev` and automatically reloads on file changes.

### Production build and run

```bash
npm run build   # compile TypeScript to dist/
npm start       # run compiled JavaScript from dist/server.js
```

By default the application listens on:

- `PORT` environment variable if it is set;
- otherwise port `3000`.

So locally the base URL is usually:

- `http://localhost:3000`

---

## Running with Docker

You can run the service inside a Docker container.

### Build and run with Docker directly

```bash
docker build -t coinkeeper .
docker run -p 8080:3000 -e PORT=3000 coinkeeper
```

The service will be available at:

- `http://localhost:8080/`
- `http://localhost:8080/healthcheck`

### Run with Docker Compose

The repository contains a `docker-compose.yml` file.

```bash
docker-compose up --build
```

After the containers start, the backend will be available at:

- `http://localhost:8080/`
- `http://localhost:8080/healthcheck`

---

## API Reference

All endpoints are prefixed only by their path (no versioning). Examples below assume `http://localhost:3000` as base URL.

### Common

#### `GET /`

Simple welcome endpoint to verify that the service is reachable.

- **Status:** `200 OK`
- **Response body (text):**

  ```text
  Welcome to CoinKeeper!
  ```

#### `GET /healthcheck`

Healthcheck endpoint used for Render and local monitoring.

- **Status:** `200 OK`
- **Response (JSON):**

  ```json
  {
    "date": "2025-01-01T00:00:00.000Z",
    "status": "OK",
    "message": "Healthcheck passed"
  }
  ```

The `date` field is generated on each request with the current server time in ISO 8601 format.

---

### Data Model (Lab 2)

All data in Lab 2 is stored **in memory only** – there is no database yet.

- **User**
  - `id` – number
  - `name` – string

- **Category**
  - `id` – number
  - `name` – string

- **Record**
  - `id` – number
  - `userId` – number (existing user)
  - `categoryId` – number (existing category)
  - `createdAt` – ISO datetime string (generated by the server)
  - `amount` – number

IDs are generated by simple in‑memory counters.

---

### Users

#### `GET /users`

Returns all users.

- **Status:** `200 OK`
- **Response:** array of `User`

#### `GET /user/:userId`

Returns a single user by id.

- **Status 200:** user found, JSON body with `User`
- **Status 404:** `{ "error": "User not found" }`

#### `POST /user`

Creates a new user.

- **Body (JSON):**

  ```json
  {
    "name": "Andrii"
  }
  ```

- **Status 201:** created user with generated `id`
- **Status 400:** if `name` is missing

#### `DELETE /user/:userId`

Deletes a user and all of their records.

- **Status 204:** user was deleted
- **Status 404:** if user does not exist

---

### Categories

#### `GET /category`

Returns all categories.

- **Status:** `200 OK`
- **Response:** array of `Category`

#### `POST /category`

Creates a new category.

- **Body (JSON):**

  ```json
  {
    "name": "Food"
  }
  ```

- **Status 201:** created category
- **Status 400:** if `name` is missing

#### `DELETE /category/:categoryId`

Deletes a category and all records that reference it.

- **Status 204:** category deleted
- **Status 404:** if category does not exist

---

### Records

#### `GET /record/:recordId`

Returns one expense record by id.

- **Status 200:** record found
- **Status 404:** `{ "error": "Record not found" }`

#### `POST /record`

Creates a new expense record.

- **Body (JSON):**

  ```json
  {
    "userId": 1,
    "categoryId": 2,
    "amount": 123.45
  }
  ```

- Server automatically sets:
  - `id` – generated number
  - `createdAt` – current time in ISO 8601 format

- **Status 201:** created record
- **Status 400:** if fields are missing, not numbers, or if the referenced user/category does not exist

#### `GET /record`

Returns records filtered by query parameters.

- **Query parameters:**
  - `user_id` – optional user id
  - `category_id` – optional category id

Rules:

- If **neither** `user_id` nor `category_id` is provided →  
  **Status 400** with error message:
  - `"At least one of 'user_id' or 'category_id' must be provided"`
- If only `user_id` is provided → return all records of this user.
- If only `category_id` is provided → return all records in this category.
- If both are provided → return records that match **both** filters.

#### `DELETE /record/:recordId`

Deletes a record.

- **Status 204:** record deleted
- **Status 404:** if record does not exist

---

## Deployment to Render.com (example)

This project is prepared to be deployed as a **Docker web service** on Render.

Typical steps:

1. Push the project to a Git repository (e.g. GitHub).
2. In Render, create **New → Web Service**.
3. Choose:
   - **Environment / Language:** `Docker`
   - **Branch:** `main`
4. Leave the root directory empty (or set it to the folder name if the project is inside a subdirectory).
5. Keep default Docker build settings – Render will build the image using the `Dockerfile` in the repository.
6. After deployment, Render will expose a public URL such as:

   - `https://coinkeeper-m784.onrender.com`

7. Verify the service:

   - `https://coinkeeper-m784.onrender.com/healthcheck`
   - `https://coinkeeper-m784.onrender.com/users` (after you create some users)
   - `https://coinkeeper-m784.onrender.com/record` (with query parameters)

---

## Postman Flow

The following flow was created in Postman to demonstrate how the API can be used end-to-end:

![CoinKeeper Postman Flow](lab2-flow.jpg)

## Labs Mapping

### Lab 1 – Backend preparation

This project satisfies the Lab 1 requirements:

- ✅ Backend environment configured (Node.js + TypeScript + Express).
- ✅ Healthcheck endpoint implemented (`GET /healthcheck`).
- ✅ Service can be run locally and in Docker.
- ✅ Project prepared for deployment on Render.com (uses `PORT` env variable).
- ✅ README with clear instructions for setup and manual testing.

### Lab 2 – In‑memory REST API

This project also covers Lab 2:

- ✅ In‑memory data model for **users**, **categories** and **records**.
- ✅ Full CRUD endpoints for all entities (except updates, which are not required).
- ✅ Special behaviour for `GET /record`:
  - returns **400 Bad Request** when called without `user_id` or `category_id`.
- ✅ All endpoints can be tested via Postman / Insomnia and used in Postman Collections & Flows required by the lab.

The same codebase can be extended in later labs with validation, database support and authentication without changing the public API.


## Lab 3 – Validation, error handling and ORM (status)

This project also covers the requirements of **Lab 3 “Валідація, обробка помилок, ORM”**:

- ✅ Валідація вхідних даних для основних ендпоінтів (користувачі, категорії, транзакції) за допомогою схем у директорії `src/schemas` та проміжного шару `src/middleware`.
- ✅ Централізована обробка помилок на рівні Express‑middleware: коректні HTTP‑коди, структурована JSON‑відповідь з повідомленням про помилку.
- ✅ Використання ORM (**Prisma**) для роботи з PostgreSQL – описані моделі (наприклад, `User`, `Category`, `Record`), міграції зберігаються в директорії `prisma/migrations`.
- ✅ Підключення справжньої бази даних PostgreSQL як локально (через Docker Compose), так і у продакшені (managed PostgreSQL на Render).
- ✅ Оновлена Postman‑колекція для тестування ендпоінтів з урахуванням роботи з базою даних.

> **Варіант лабораторної 3.** Згідно з методичними вказівками, варіант визначається як остача від ділення номера групи на 3 (1 – валюти, 2 – користувацькі категорії витрат, 0 – облік доходів). Тут у README потрібно явно вказати ваш номер групи, остачу та обраний варіант (функціонал валюти / кастомних категорій / рахунків і доходів) – цю одну фразу можна легко підправити вручну під конкретну групу.


## Deployment and Usage

### Local development

1. Install dependencies:

```bash
npm install
```

2. Set up a local PostgreSQL database and specify the connection string in the `DATABASE_URL` environment variable, for example:

```bash
DATABASE_URL="postgresql://postgres:postgres@localhost:5432/coinkeeper?schema=public"
```

You can keep this value in a `.env` file in the project root:

```env
DATABASE_URL=postgresql://postgres:postgres@localhost:5432/coinkeeper?schema=public
PORT=10000
```

3. Run database migrations with Prisma:

```bash
npx prisma migrate dev --name init
```

4. Start the application in development mode:

```bash
npm run dev
```

The API will be available on `http://localhost:10000` (or on the port specified in `PORT`).

### Running with Docker

The project contains a `Dockerfile` and a `docker-compose.yml` for running the service together with PostgreSQL.

1. Build and start the containers:

```bash
docker compose up --build
```

2. After the containers start, apply the migrations inside the application container (once per database):

```bash
docker compose exec coinkeeper npx prisma migrate deploy
```

After that, the service will be ready to accept requests.

### Deploying to Render

For deployment to Render as a web service:

1. Push the project to a Git repository (GitHub, GitLab, etc.).
2. In the Render dashboard create:
   - a **PostgreSQL** managed database,
   - a **Web Service** from the repository with the backend.

3. In the Web Service settings configure environment variables:

- `DATABASE_URL` – connection string to the Render PostgreSQL database (can be copied from the database settings);
- `PORT` – application port (for example, `10000`).

4. Set the build and start commands, for example:

- **Build command:**

```bash
npm install
npm run build
npx prisma migrate deploy
```

- **Start command:**

```bash
npm run start
```

Render will build the image, apply migrations to the managed PostgreSQL database and start the service.

### API and Postman collection

The CoinKeeper API provides endpoints for working with:

- users,
- categories,
- records (transactions).

For convenient testing there is a Postman collection and environment; they describe requests for creating users, categories, records and for retrieving data with filters. These files can be imported into Postman to quickly check the work of the API both locally and on the deployed Render instance.
